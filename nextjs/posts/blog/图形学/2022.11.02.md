---
title: Taichi 实现 FEM
date: 2022-11-02
---

有限元方法（FEM）常用于模拟弹性物体，其思想为将连续材料离散成多个 element，三维中最常用的是四面体，通过 element 的势能来计算内力。

## 1. 形变梯度
对于每个四面体，它的形变都可以表示成如下形式
$$
\vec{x}_1-\vec{x}_4 = \bold F(\vec{X}_1-\vec{X}_4)
$$
$$
\vec{x}_2-\vec{x}_4 = \bold F(\vec{X}_2-\vec{X}_4)
$$
$$
\vec{x}_3-\vec{x}_4 = \bold F(\vec{X}_3-\vec{X}_4)
$$
或
$$
\bold D_s = \bold F\bold D_m
$$
$\bold F$ 即描述物体形变的形变梯度矩阵，四面体的体积可以表示为
$$
\bold W = \frac{1}{6}|det(\bold D_m)|
$$
当四面体的体积大于 0 时形变梯度可以表示为
$$
\bold F = \bold D_s\bold D_m^{-1} = \bold D\bold B
$$

## 2. 应变能量密度
在物体形变过程中会产生能量，根据 Corotated 模型，能量密度和应力张量为
$$
\Psi(\bold F) = \mu\sum_i{(\sigma_i - 1)^2+\frac{\lambda}{2}(J-1)^2}
$$
$$
\bold P(\bold F) = \frac{\partial\Psi}{\partial F} = 2\mu(\bold F - \bold R) + \lambda(J-1)J\bold F^{-T}
$$
四面体的势能即为
$$
U = \bold W\cdot\bold\Psi(\bold F)
$$

## 3. 应变力
根据势能，应变力的计算即为
$$
\bold f_i = -\frac{\partial U}{\partial\bold x_i} = -\sum_e{\bold W\bold P(\bold F_e)\frac{\partial\bold F_e}{\partial\bold x_i}}
$$
对于一个 element
$$
\bold H = -\bold W\bold P(\bold F)\bold B = [\bold f_1, \bold f_2, \bold f_3]
$$
$$
\bold f_4 = - \bold f_1 - \bold f_2 - \bold f_3
$$

## 4. 显示方法实现
对于显示方法，即计算应变力后直接更新速度和位置
```python
@ti.func
def D(self, e):
    return ti.Matrix.cols([self.x[self.elements[e][i]] - self.x[self.elements[e][3]] for i in range(3)])

@ti.kernel
def compute_f(self):
    for i in self.f:
        self.f[i] = self.gravity * self.m[i]
    for e in self.elements:
        F = self.D(e) @ self.F_B[e]
        P = ti.Matrix.zero(ti.f32, 3, 3)
        U, sig, V = ssvd(F)
        P = 2 * self.mu * (F - U @ V.transpose())
        H = -self.F_W[e] * P @ self.F_B[e].transpose()
        for i in ti.static(range(3)):
            force = ti.Vector([H[j, i] for j in range(3)])
            self.f[self.elements[e][i]] += force
            self.f[self.elements[e][3]] -= force

@ti.kernel
def update_xv(self):
    for i in range(self.n):
        self.v[i] += self.dt * (self.f[i] / self.m[i])
        self.x[i] += self.dt * self.v[i]
```

## 5. 隐式方法实现
隐式方法与弹簧质点系统中一样，也是求解下面这个线性方程
$$
[\bold I-\Delta t^2\bold M^{-1}\frac{\partial \bold f}{\partial \bold x}(\bold x_t)]\bold v_{t+1} = \bold v_t + \Delta t\bold M^{-1}\bold f(\bold x_{t})
$$
主要是对内力求导，根据上面
$$
\bold H = -\bold W\bold P(\bold F)\bold B
$$
$$
d\bold H = -\bold W\bold B\cdot d\bold P(\bold F)
$$
$$
d\bold P = 2\mu\cdot d\bold F
$$
$$
\frac{\partial\bold F_i}{\partial\bold x_{ik}} = \left\{
    \begin{aligned}
    & \hat{\bold e}_1\hat{\bold e}_k\bold B &&, k = 1, 2, 3 \\
    & -\hat{\bold e}_1\hat{\bold e}\bold B &&, k = 4
    \end{aligned}
\right.
$$
$\frac{\partial\bold F_i}{\partial\bold y_{ik}}$，$\frac{\partial\bold F_i}{\partial\bold z_{ik}}$ 将上式中的 $\hat{\bold e}_1$ 分别改为 $\hat{\bold e}_2$，$\hat{\bold e}_3$ 即可，$\hat{\bold e}_i$ 指单位矩阵第 $i$ 列对应的列向量，$\hat{\bold e}$ 指元素全为 1 的向量。

矩阵 $\bold A$ 和 $\bold b$ 的计算实现如下
```python
@ti.kernel
def compute_b(self):
    for i in range(self.n):
        self.b[i] = self.m[i] * self.v[i] + self.dt * self.f[i]

@ti.kernel
def compute_A(self):
    I = ti.Matrix.identity(ti.f32, 3)
    for i, j in ti.ndrange(self.n, self.n):
        if i == j:
            self.A[i, j] = self.m[i] * I
        else:
            self.A[i, j].fill(0)
    for e in self.elements:
        verts = self.elements[e]
        W_c = self.F_W[e]
        B_c = self.F_B[e]
        for u in ti.static(range(4)):
            for d in ti.static(range(3)):
                dD = ti.Matrix.zero(ti.f32, 3, 3)
                if ti.static(u == 3):
                    for j in ti.static(range(3)):
                        dD[d, j] = -1
                else:
                    dD[d, u] = 1
                dF = dD @ self.F_B[e]
                dP = 2.0 * self.mu * dF
                dH = -W_c * dP @ B_c.transpose()
                for i in ti.static(range(3)):
                    for j in ti.static(range(3)):
                        self.A[verts[u], verts[i]][d, j] += -self.dt**2 * dH[j, i]
                        self.A[verts[u], verts[3]][d, j] += self.dt**2 * dH[j, i]
```
下面实现 MGPCG 的迭代求解
```python
@ti.func
def A_coarsen(self, i, j, l):
    sum = ti.Matrix.zero(ti.f32, self.dim, self.dim)
    dim = 2 ** l
    for m, n in ti.ndrange(dim, dim):
        sum += self.A[i*dim+m, j*dim+n]
    return sum / dim / dim

@ti.kernel
def init_mgpcg(self):
    for i in range(self.n):
        self.r[0][i] = self.b[i]
        for j in range(self.n):
            self.r[0][i] -= self.A[i, j] @ self.x[j]
    self.precondition()

@ti.func
def smooth(self, l: ti.template()):
    dim = self.n // (2 ** l)
    for i in range(dim):
        r = self.r[l][i]
        for j in range(dim):
            if i != j:
                r -= self.A_coarsen(i, j, l) @ self.z[l][j]
        self.z[l][i] = self.A_coarsen(i, i, l).inverse() @ r

@ti.func
def coarsen(self, l: ti.template()):
    dim = self.n // (2 ** l)
    for i in range(dim):
        r = self.r[l][i]
        for j in range(dim):
            r -= self.A_coarsen(i, j, l) @ self.z[l][j]
        self.r[l+1][i // 2] += 0.5 * r

@ti.func
def refine(self, l: ti.template()):
    dim = self.n // (2 ** l)
    for i in range(dim):
        self.z[l][i] += self.z[l+1][i // 2]

@ti.func
def precondition(self):
    self.z[0].fill(0)
    for l in ti.static(range(self.mg_levels - 1)):
        for _ in range(self.smooth_iter):
            self.smooth(l)
        self.r[l+1].fill(0)
        self.z[l+1].fill(0)
        self.coarsen(l)
    for _ in range(self.smooth_iter):
        self.smooth(self.mg_levels - 1)
    for l in ti.static(range(self.mg_levels - 2, -1, -1)):
        self.refine(l)
        for _ in range(self.smooth_iter):
            self.smooth(l)

@ti.kernel
def mgpcg_iteration(self) -> ti.f32:
    zr = 0.0
    pAp = 0.0
    zr1 = 0.0
    rr = 0.0
    for i in range(self.n):
        zr += self.z[0][i].dot(self.r[0][i])
        self.Ap[i] = ti.Vector.zero(dt=ti.f32, n=self.dim)
        for j in range(self.n):
            self.Ap[i] += self.A[i, j] @ self.p[j]
        pAp += self.p[i].dot(self.Ap[i])
    alpha = zr / pAp
    for i in range(self.n):
        self.x[i] += alpha * self.p[i]
        self.r[0][i] -= alpha * self.Ap[i]
    self.precondition()
    for i in range(self.n):
        zr1 += self.z[0][i].dot(self.r[0][i])
    beta = zr1 / zr
    for i in range(self.n):
        self.p[i] = self.r[0][i] + beta * self.p[i]
        rr += self.r[0][i].dot(self.r[0][i])
    return rr

self.init_mgpcg()
self.p.copy_from(self.z[0])
for iter in range(self.max_iter):
    if self.mgpcg_iteration() < self.epsilon:
        break
```