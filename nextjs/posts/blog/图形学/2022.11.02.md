---
title: Taichi 实现 FEM
date: 2022-11-02
---

有限元方法（FEM）常用于模拟弹性物体，其思想为将连续材料离散成多个 element，三维中最常用的是四面体，通过 element 的势能来计算内力。

## 1. 形变梯度
对于每个四面体，它的形变都可以表示成如下形式
$$
\vec{x}_1-\vec{x}_4 = \bold F(\vec{X}_1-\vec{X}_4)
$$
$$
\vec{x}_2-\vec{x}_4 = \bold F(\vec{X}_2-\vec{X}_4)
$$
$$
\vec{x}_3-\vec{x}_4 = \bold F(\vec{X}_3-\vec{X}_4)
$$
或
$$
\bold D_s = \bold F\bold D_m
$$
$\bold F$ 即描述物体形变的形变梯度矩阵，四面体的体积可以表示为
$$
\bold W = \frac{1}{6}|det(\bold D_m)|
$$
当四面体的体积大于 0 时形变梯度可以表示为
$$
\bold F = \bold D_s\bold D_m^{-1} = \bold D\bold B
$$

## 2. 应变能量密度
在物体形变过程中会产生能量，根据 Corotated 模型，能量密度和应力张量为
$$
\Psi(\bold F) = \mu\sum_i{(\sigma_i - 1)^2+\frac{\lambda}{2}(J-1)^2} = \mu\sum_i{(\sigma_i - 1)^2+\frac{\lambda}{2}tr^2(\bold{R}^T\bold{F} - \bold{I})}
$$
$$
\bold P(\bold F) = \frac{\partial\Psi}{\partial\bold F} = 2\mu(\bold F - \bold R) + \lambda(J-1)J\bold F^{-T} = 2\mu(\bold F - \bold R) + \lambda tr(\bold{R}^T\bold{F} - \bold{I})\bold{R}
$$
四面体的势能即为
$$
U = \bold W\cdot\bold\Psi(\bold F)
$$

## 3. 应变力
根据势能，应变力的计算即为
$$
\bold f_i = -\frac{\partial U}{\partial\bold x_i} = -\sum_e{\bold W\bold P(\bold F_e)\frac{\partial\bold F_e}{\partial\bold x_i}}
$$
对于一个 element
$$
\bold H = -\bold W\bold P(\bold F)\bold B^T = [\bold f_1, \bold f_2, \bold f_3]
$$
$$
\bold f_4 = - \bold f_1 - \bold f_2 - \bold f_3
$$

## 4. 显示方法实现
对于显示方法，即计算应变力后直接更新速度和位置
```python
@ti.func
def D(self, e):
    return ti.Matrix.cols([self.x[self.elements[e][i]] - self.x[self.elements[e][3]] for i in range(3)])

@ti.kernel
def compute_f(self):
    for i in self.f:
        self.f[i] = self.gravity * self.m[i]
    for e in self.elements:
        F = self.D(e) @ self.F_B[e]
        P = ti.Matrix.zero(ti.f32, 3, 3)
        U, sig, V = ssvd(F)
        R = U @ V.transpose()
        P = 2 * self.mu * (F - R) + self.la * (R.transpose() @ F - I).trace() * R
        H = -self.F_W[e] * P @ self.F_B[e].transpose()
        for i in ti.static(range(3)):
            force = ti.Vector([H[j, i] for j in range(3)])
            self.f[self.elements[e][i]] += force
            self.f[self.elements[e][3]] -= force

@ti.kernel
def update_xv(self):
    for i in range(self.n):
        self.v[i] += self.dt * (self.f[i] / self.m[i])
        self.x[i] += self.dt * self.v[i]
```

## 5. 隐式方法实现
隐式方法与弹簧质点系统中一样，也是求解下面这个线性方程
$$
[\bold I-\Delta t^2\bold M^{-1}\frac{\partial \bold f}{\partial \bold x}(\bold x_t)]\bold v_{t+1} = \bold v_t + \Delta t\bold M^{-1}\bold f(\bold x_{t})
$$
主要是对内力求导，根据上面
$$
\bold H = -\bold W\bold P(\bold F)\bold B^T
$$
$$
d\bold H = -\bold W\bold B^T\cdot d\bold P(\bold F)
$$
$$
d\bold P = 2\mu\cdot d\bold F - 2\mu\cdot d\bold R + \lambda (\bold Rd\bold F + \bold Fd\bold R) \bold R + \lambda tr(\bold R^T\bold F - \bold I)d\bold R
$$
由于
$$
(\bold R^Td\bold R)^T + \bold R^Td\bold R = 0
$$
因此$\bold R^Td\bold R$是斜对称矩阵，令
$$
\bold R^Td\bold R = \bold r_x = \left(
\begin{matrix}
0 & -r_3 & r_2 \\
r_3 & 0 & -r_1 \\
-r_2 & r_1 & 0
\end{matrix}
\right)
$$
因此
$$
dR = \bold R \bold r_x
$$
这里$\bold r_x$即为斜对称矩阵表示，向量$\bold r = (r_1, r_2, r_3)$的计算如下
$$
\bold r = (\bold S-tr(\bold S)\bold I)^{-1}\bold w
$$
这里 $\bold w$ 表示为
$$
\bold w = \left(
\begin{matrix}
w_{23} - w_{32} \\
w_{31} - w_{13} \\
w_{12} - w_{21}
\end{matrix}
\right)
$$
$$
\bold W = \bold R^Td\bold F = \left(
\begin{matrix}
w_{11} & w_{12} & w_{13} \\
w_{21} & w_{22} & w_{23} \\
w_{31} & w_{32} & w_{33}
\end{matrix}
\right)
$$
最后只需要计算$\bold F$对$\bold x$的导数
$$
\frac{\partial\bold F_i}{\partial\bold x_{ik}} = \left\{
    \begin{aligned}
    & \hat{\bold e}_1\hat{\bold e}_k^T\bold B &&, k = 1, 2, 3 \\
    & -\hat{\bold e}_1\hat{\bold e}^T\bold B &&, k = 4
    \end{aligned}
\right.
$$
$\frac{\partial\bold F_i}{\partial\bold y_{ik}}$，$\frac{\partial\bold F_i}{\partial\bold z_{ik}}$ 将上式中的 $\hat{\bold e}_1$ 分别改为 $\hat{\bold e}_2$，$\hat{\bold e}_3$ 即可，$\hat{\bold e}_i$ 指单位矩阵第 $i$ 列对应的列向量，$\hat{\bold e}$ 指元素全为 1 的向量。

矩阵 $\bold A$ 和 $\bold b$ 的计算实现如下
```python
@ti.kernel
def compute_b(self):
    for i in range(self.n):
        self.b[i] = self.m[i] * self.v[i] + self.dt * self.f[i]

@ti.kernel
def compute_A(self):
        I = ti.Matrix.identity(ti.f32, 3)
        for i, j in ti.ndrange(self.n_verts, self.n_verts):
            if i == j:
                self.solver.A[i, j] = self.m[i] * I
            else:
                self.solver.A[i, j].fill(0)
        for e in self.elements:
            verts = self.elements[e]
            W_c = self.F_W[e]
            B_c = self.F_B[e]
            F = self.D(e) @ self.F_B[e]
            R, S = ti.polar_decompose(F, ti.f32)
            rwinv = (S - S.trace() * I).inverse()
            for u in ti.static(range(4)):
                for d in ti.static(range(3)):
                    dD = ti.Matrix.zero(ti.f32, 3, 3)
                    if ti.static(u == 3):
                        for j in ti.static(range(3)):
                            dD[d, j] = -1
                    else:
                        dD[d, u] = 1
                    dF = dD @ B_c
                    W = R.transpose() @ dF
                    w = ti.Vector([W[1, 2] - W[2, 1], W[2, 0] - W[0, 2], W[0, 1] - W[1, 0]])
                    r = rwinv @ w
                    rx = ti.Matrix([[0, -r[2], r[1]], [r[2], 0, -r[0]], [-r[1], r[0], 0]])
                    dR = R @ rx
                    dP = 2.0 * self.mu * (dF - dR) + self.la * (R @ dF + F @ dR) @ R + self.la * (R.transpose() @ F - I).trace() * dR
                    dH = -W_c * dP @ B_c.transpose()
                    for i in ti.static(range(3)):
                        for j in ti.static(range(3)):
                            self.solver.A[verts[u], verts[i]][d, j] += -self.dt**2 * dH[j, i]
                            self.solver.A[verts[u], verts[3]][d, j] += self.dt**2 * dH[j, i]
```
下面实现 MGPCG 的迭代求解
```python
@ti.func
def A_coarsen(self, i, j, l):
    sum = ti.Matrix.zero(ti.f32, self.dim, self.dim)
    dim = 2 ** l
    for m, n in ti.ndrange(dim, dim):
        sum += self.A[i*dim+m, j*dim+n]
    return sum / dim / dim

@ti.kernel
def init_mgpcg(self):
    for i in range(self.n):
        self.r[0][i] = self.b[i]
        for j in range(self.n):
            self.r[0][i] -= self.A[i, j] @ self.x[j]
    self.precondition()

@ti.func
def smooth(self, l: ti.template()):
    dim = self.n // (2 ** l)
    for i in range(dim):
        r = self.r[l][i]
        for j in range(dim):
            if i != j:
                r -= self.A_coarsen(i, j, l) @ self.z[l][j]
        self.z[l][i] = self.A_coarsen(i, i, l).inverse() @ r

@ti.func
def coarsen(self, l: ti.template()):
    dim = self.n // (2 ** l)
    for i in range(dim):
        r = self.r[l][i]
        for j in range(dim):
            r -= self.A_coarsen(i, j, l) @ self.z[l][j]
        self.r[l+1][i // 2] += 0.5 * r

@ti.func
def refine(self, l: ti.template()):
    dim = self.n // (2 ** l)
    for i in range(dim):
        self.z[l][i] += self.z[l+1][i // 2]

@ti.func
def precondition(self):
    self.z[0].fill(0)
    for l in ti.static(range(self.mg_levels - 1)):
        for _ in range(self.smooth_iter):
            self.smooth(l)
        self.r[l+1].fill(0)
        self.z[l+1].fill(0)
        self.coarsen(l)
    for _ in range(self.smooth_iter):
        self.smooth(self.mg_levels - 1)
    for l in ti.static(range(self.mg_levels - 2, -1, -1)):
        self.refine(l)
        for _ in range(self.smooth_iter):
            self.smooth(l)

@ti.kernel
def mgpcg_iteration(self) -> ti.f32:
    zr = 0.0
    pAp = 0.0
    zr1 = 0.0
    rr = 0.0
    for i in range(self.n):
        zr += self.z[0][i].dot(self.r[0][i])
        self.Ap[i] = ti.Vector.zero(dt=ti.f32, n=self.dim)
        for j in range(self.n):
            self.Ap[i] += self.A[i, j] @ self.p[j]
        pAp += self.p[i].dot(self.Ap[i])
    alpha = zr / pAp
    for i in range(self.n):
        self.x[i] += alpha * self.p[i]
        self.r[0][i] -= alpha * self.Ap[i]
    self.precondition()
    for i in range(self.n):
        zr1 += self.z[0][i].dot(self.r[0][i])
    beta = zr1 / zr
    for i in range(self.n):
        self.p[i] = self.r[0][i] + beta * self.p[i]
        rr += self.r[0][i].dot(self.r[0][i])
    return rr

self.init_mgpcg()
self.p.copy_from(self.z[0])
for iter in range(self.max_iter):
    if self.mgpcg_iteration() < self.epsilon:
        break
```